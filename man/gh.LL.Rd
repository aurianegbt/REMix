% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gh_LL.R
\name{gh.LL}
\alias{gh.LL}
\title{Adaptive Gauss-Hermite Approximation of Log-Likelihood Derivatives}
\usage{
gh.LL(
  dynFUN,
  y,
  mu = NULL,
  Omega = NULL,
  theta = NULL,
  alpha1 = NULL,
  covariates = NULL,
  ParModel.transfo = NULL,
  ParModel.transfo.inv = NULL,
  Sobs = NULL,
  Robs = NULL,
  Serr = NULL,
  Rerr = NULL,
  ObsModel.transfo = NULL,
  data = NULL,
  n = NULL,
  prune = NULL,
  parallel = TRUE,
  ncores = NULL,
  onlyLL = FALSE,
  print = TRUE
)
}
\arguments{
\item{dynFUN}{Dynamic function. This function need to contain every sub-function that it may needs as it is called in a foreach loop. The output of this function need to return a data.frame with `time` as first columns and named dynamics in other columns. It must take in input : \itemize{\item `y` a named vector with the initial condition. The names are the dynamics names.
\item `parms` a named vector of parameter.
\item `time` vector a timepoint.}

See \code{\link{dynFUN_demo}} for example.}

\item{y}{Initial condition of the model, conforming to what is required in `dynFUN`.}

\item{mu}{List of named vectors of individual random effects estimations (size N, each vector has size m). Individuals must be sorted in the same order in `Omega` and `covariates`.}

\item{Omega}{List of named diagonal matrices of individual standard deviation estimations (size N, each element is size m x m). Individuals must be sorted in the same order in `mu` and `covariates`.}

\item{theta}{Model parameters : contains `phi_pop` (size L), `psi_pop` (size m), `gamma` (list of size L, each containing a vector of size m), `beta` (list of size m, each containing a vector of size m), and `alpha0` (size K).}

\item{alpha1}{Regularization parameter (size K). It should be named with observation model names.}

\item{covariates}{Matrix of individual covariates (size N x n). Individuals must be sorted in the same order in `mu` and `Omega`.}

\item{ParModel.transfo}{Named list of transformation functions for the individual parameter model (names must be consistent with `phi_pop` and `psi_pop`, missing entries default to identity).}

\item{ParModel.transfo.inv}{Named list of inverse transformation functions for the individual parameter model (names must be consistent with `phi_pop` and `psi_pop`, missing entries default to identity).}

\item{Sobs}{List (size N) of lists of direct observations (size P), each element containing time and observation (in column 3). The element list name must be the observation variable names.}

\item{Robs}{List (size N) of latent observations (size K), each element containing time and observation (in column 3). The element list name must be the observation variable names. (same as in `ObsModel.transfo$link[...]`, etc.)}

\item{Serr}{Named ector of size P containing estimated error model constants (must be in the same order as in `Sobs`). It should be named with observation model names.}

\item{Rerr}{Vector of size K containing estimated error model constants (must be in the same order as in `Robs`). It should be named with unique observation model names.}

\item{ObsModel.transfo}{List containing two lists of transformations and two vectors with their corresponding links to the observation models names. The list should include identity transformations and be named `S` and `R`. It should also include two vectors, `linkS` and `linkR`, which link to the observation models.

Both `ObsModel.transfo$S` (for direct observation models) and `ObsModel.transfo$linkS`, as well as `ObsModel.transfo$R` (for latent process models) and `ObsModel.transfo$linkR`, must have the same length.

\itemize{
  \item `ObsModel.transfo$S`: A list of transformations for the direct observation model. Each transformation corresponds to a variable \eqn{Y_p=h_p(S_p)}, where the name indicates which dynamic is observed. The `linkS` vector specifies the observation model name given in other inputs for each transformation, in the same order as in `ObsModel.transfo$S`.

  \item `ObsModel.transfo$R`: A list of transformations for the latent process model. Although currently there is only one latent dynamic, each \eqn{s_k} transformation corresponds to the same dynamic but may vary for each \eqn{Y_k} observed. The names should match the output from `dynFUN`. The `linkR` vector specifies the observation model names for each transformation, in the same order as in `ObsModel.transfo$R`.
}}

\item{data}{A list containing all `mu`, `Omega`, `theta`, `alpha1`, `covariates`, `ParModel.transfo`, `ParModel.transfo.inv`, `Sobs`, `Robs`, `Serr`, `Rerr`, and `ObsModel.transfo`, which can be obtained using \code{\link{readMLX}} from a monolix project. If any of these arguments are specified, they will be used in priority.}

\item{n}{Number of points for the adaptative Gaussian quadrature (default is \code{floor(100^(1/length(theta$psi_pop)))}).}

\item{prune}{Percentage for pruning in [0, 1] (default is NULL).}

\item{parallel}{If the computation should be done in parallel (default is TRUE).}

\item{ncores}{Number of cores for parallelization (default is NULL).}

\item{onlyLL}{If only the log-likelihood needs to be returned (default is FALSE).}
}
\value{
A list with the approximation by Gauss-Hermite quadrature of the likelihood `L`, the log-likelihood `LL`, the gradient of the log-likelihood `dLL`, and the Hessian of the log-likelihood `ddLL` at the point \eqn{\theta, \alpha}.
}
\description{
Computes the adaptive Gauss-Hermite approximation of the log-likelihood and its derivatives in NLMEM with latent observation processes.
}
\details{
Suppose we have a differential system of equations containing variables \eqn{(S_{p})_{p\leq P}} and \eqn{R} that depend on some parameters. These dynamics are described by `dynFUN`. We model the process over time for \eqn{i \leq N} individuals, resulting from the differential system for a set of parameters \eqn{\phi_i} and \eqn{(\psi_{li})_{l\leq m, i\leq N}} for individual \eqn{i \leq N}, as \eqn{S_{p}(\cdot, \phi_i, (\psi_{li})_{l\leq m}) = S_{pi}(\cdot)}, \eqn{p \leq P}, and \eqn{R(\cdot, \phi_i, (\psi_{li})_{l\leq m}) = R_i(\cdot)}.

Parameters are described as \deqn{h_l(\psi_{li}) = h_l(\psi_{lpop}) + X_i \beta_l + \eta_{li}}, where the covariates of individual \eqn{i \leq N} are contained in the rows of the matrix `covariates`, and random effects \deqn{\eta_i = (\eta_{li})_{l \leq m} \overset{iid}{\sim} \mathcal{N}(\mu_i, \Omega_i)} for \eqn{i \leq N}, where \eqn{\mu_i} (in the list `mu`) is the estimated random effect of individual \eqn{i} and \eqn{\Omega_i} (in the list `Omega`) is the diagonal matrix of estimated standard deviations of random effects for individual \eqn{i}. The population parameters \eqn{\psi_{pop} = (\psi_{lpop})_{l \leq m}} (contained in `theta` through `psi_pop`) and \eqn{\beta = (\beta_l)_{l \leq m}} (contained in `theta` through `beta`) form the vector of covariate effects on parameters.

The remaining population parameters of the structural model, which do not have random effects, are denoted by \eqn{(\phi_i)_{i \leq N}}, and are defined as \eqn{\phi_i = \phi_{pop} + X_i \gamma}. These can depend on covariate effects or be constant across the population. The population parameters \eqn{\phi_{pop}} are contained in `theta` through `phi_pop`, and the covariate effects coefficients \eqn{\gamma} are contained in `theta` through `gamma`.

We assume that individual trajectories \eqn{(S_{pi})_{p \leq P, i \leq N}} are observed through a direct observation model, up to a transformation \eqn{g_p}, \eqn{p \leq P}, at different times \eqn{(t_{pij})_{i \leq N, p \leq P, j \leq n_{ip}}}: \deqn{Y_{pij} = g_p(S_{pi}(t_{pij})) + \epsilon_{pij}}, contained in the list `Sobs` with error \eqn{\epsilon_p = (\epsilon_{pij}) \overset{iid}{\sim} \mathcal{N}(0, \varsigma_p^2)} for \eqn{p \leq P} (with \eqn{(\varsigma_p)_{p \leq P}} contained in `Serr`).

The individual trajectory \eqn{(R_{i})_{i \leq N}} is observed through latent processes, up to a transformation \eqn{s_k}, \eqn{k \leq K}, observed at \eqn{(t_{kij})_{i \leq N, k \leq K, j \leq n_{kij}}}: \deqn{Z_{kij} = \alpha_{k0} + \alpha_{k1} s_k(R_i(t_{kij})) + \varepsilon_{kij}} (contained in the list `Robs`), where \eqn{\varepsilon_k \overset{iid}{\sim} \mathcal{N}(0, \sigma_k^2)} (with \eqn{(\sigma_k)_{k \leq K}} contained in `Rerr`).
}
\examples{
project <- getMLXdir()


ObsModel.transfo = list(S=list(AB=log10),
                        linkS="yAB",
                        R=rep(list(S=function(x){x}),5),
                        linkR = paste0("yG",1:5))

alpha=list(alpha0=NULL,
           alpha1=setNames(paste0("alpha_1",1:5),paste0("yG",1:5)))

data <- readMLX(project,ObsModel.transfo,alpha)

LL <- gh.LL(dynFUN = dynFUN_demo,
            y = c(S=5,AB=1000),
            ObsModel.transfo=ObsModel.transfo,
            data = data)

print(LL)
}
